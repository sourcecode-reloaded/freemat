What I want:

The base class needs to _not_ be templated.

class Array {
   // size inquiries go here
   Array getVectorSubset(IndexArray);
   Array getNDimSubset(IndexArray);      
   void setVectorSubset(IndexArrayVector, Array dataArray);
   void setNDimSubset(IndexArrayVector, Array dataArray);
   void resize(const Dimensions &a);
   void vectorResize(int n):
   void reshape(const Dimensions& a);
};

//template <typename T>
//class ScalarArray : public Array {
//   T value;
//};

class StructArray : public Array {
   NDimArray<ArrayVector> data;
   Vector<String> fieldnames;
public:
   int insertFieldName(String fieldname);
   int getFieldIndex(String fieldname);
};

template <typename T>
class NumericArray : public Array {
   NDimArray<T> real_data;
   NDimArray<T> imag_data;
public:
};

template <typename T>
class SparseArray : public Array {
   SparseMatrix<T> real_data;
   SparseMatrix<T> imag_data;
};

class StringArray : public Array {
   NDimArray<uint16> data;
public:
};

class IndexArray : public Array {
   NDimArray<int64> data;
};

class CellArray : public Array {
   NDimArray<Array> data;
public:      
   Array getVectorContents(IndexArray);
   ArrayVector getVectorContentsAsList(IndexArray);
   Array getNDimContents(IndexArrayVector);
   ArrayVector getNDimContentsAsList(IndexArrayVector);
};

One way to make the NDimArray class work is with

class Ntuple;

template <typename T>
class NDimArray {
   SharedArray<T> m_base;
   NTuple         m_dims;
   NTuple         m_stride;
   int64          m_offset;
};

To support slicing...

How does this represent slices?

A(1,:) -->  Can't do it

A(:,3) -->  Can do it

A(:,:,3) --> offset

The stride part only helps for expressions like

A(1:5:end,1:5:end) --> stride

or maybe if we have

A(3:5,3:5) -- > Can't do it

RCS mode for sparse matrices...

Suppose we want to 



Can we do reference counting (atomic) with slicing?

template <typename T>
class Memblock : public QSharedData {
  std::vector<T> data;
  int length;
  MemBlock
};

template <typename T>
class Block {
  QSharedPointer<Memblock<T> > root;
  bool sliced;
  int sliceOffset;
  int sliceLength;
};

Suppose we have 

a = b(:,3) -- we want "a" to just point to "b"'s block

But when "a" is copied (via detach), we do not want to copy the whole thing.

The detach mechanism works via the copy constructor..  so we can do this:

Block(const Block& copy) {
  sliced = false;
  if (!copy.sliced) {
    root = new MemBlock(copy.root->data);
  } else {
    root = new MemBlock(copy.root->data, offset, copy.root->length);
  }
}
