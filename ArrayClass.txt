Array class design.

  3:20:26 PM: i'm in the middle of jit porting. what's the correct way of rewriting this for the new ac:
  3:20:36 PM:  Array* a = tptr->array_inputs[argnum];
  ((T*)(a->getReadWriteDataPointer()))[0] = value;
  3:20:49 PM: and this
  3:20:50 PM:   Array* a = tptr->array_inputs[argnum];
  return ((T*)(a->getDataPointer()))[0];

  3:21:04 PM: these are snippets from scalar_store and scalar_load
  3:22:41 PM: Yes, I saw the function definition leak. I wasn't sure if it was just functions that were used by freemat and thus stored.
  3:23:16 PM: Well...  the second one is easy: return (*a).constRealScalar<T>()
  3:23:31 PM: or a->constRealScalar<T>(), either way
  3:23:47 PM: The first one I would do as:
  3:23:56 PM: cool
  3:24:34 PM: if (a->isArray())
  3:24:44 PM: a->set(1,Array(value));
  3:24:45 PM: else
  3:24:53 PM: a->realScalar<T>() = value;
  3:25:19 PM: brb
  3:25:42 PM: you could just do "a->set(1,Array(value))" -- that will always work.
  3:26:35 PM: but it will convert scalar encoded arrays on assignment -- not desirable.
  3:33:27 PM: what about this code in vector_load:
  3:33:29 PM: address[0] = ((T*)(a->getDataPointer()))[ndx-1];
  3:34:13 PM: address[0] = a->get(ndx).constRealScalar<T>()
  3:34:52 PM: nice
  3:39:24 PM: "vectorResize" is now "resize", right?
  3:39:31 PM: yes
  3:40:06 PM: Samit Basu is now Away (was Online)
  3:41:27 PM: i'm looking at the code - do we need to call resize before calling set or does set automatically resize arrays now?
  3:41:53 PM: basically is the first if required here:
  3:41:54 PM:     if (ndx >= a->length()) {
      a->resize(ndx);
    }
	a->set(ndx, Array( value ));

  3:42:11 PM: ?
  3:46:38 PM: Samit Basu is now Online (was Away)
  3:46:38 PM: happens automatically now.. gotta go - everyone is awake.
  3:47:01 PM: cheers
