
What is a dynamic variable?  Consider the following function

function foo
   A = fft(1:10);

In this case, we might think that "fft" is an external (global) symbol.  But 
not necessarily.  Consider the case of an eval statement:

function foo
   eval('fft = 1:10');
   A = fft(1:10);

The presence of an eval means that "fft" is now a variable.  So when we lookup
fft, we get a variable instead of the function.  The "eval" could just as
easily be hidden in a script

function foo
   do_script
   A = fft(1:10);

do_script
  fft = 1:10

So dynamic variables are ones that just ones that have to be defined at runtime.

Note that there is a problem in the current definition of local variables.  Consider

function foo
   a = 3;
   a = a + 5;

In this case, because "a" is not visible outside the scope of function "foo", it 
would be marked a local variable (it is defined before being used).  But what happens
if the variable is deleted?  Something like this:

function foo
   fft = 3;
   clear('fft');
   a = fft(1:15);

The "clear" function will delete the local variable "fft", and the next call to "fft"
will be mapped to the function "fft", not the local variable.  Yuck.  The presence of
"clear" means that "local" variables are an optimization that we cannot really make.
Instead, all variables that are not declared as global, persistent or defined as 
parameters are dynamic.

Instead of trying to do a bunch of complex analysis at compile time, I should have developed
a better cache mechanism so that variables could be looked up without a big penalty.  
Double yuck.

OK - so variables only come in the following flavors:

Global     - variables that belong to the global scope.
Persistent - variables that are "static".
Parameter  - variables that are passed as parameters (could be value or reference).
Return     - variables that are returned from a function.
Dynamic    - variables that are otherwise undefined.

The notion of "local" variables is dropped.  There is no real meaningful way to 
guarantee that a variable is truly local, except in the case of for loop variables.
And even in that case, it's really a function of speed - nothing else.  

What about "captured/free" variables?  This was considerably more difficult than regular
variables.  The situation was driven by the need/ability to nest functions.

function a = foo(y)
  x = 3+y
  function b = bar(g)
     b = x+g
  end
end

In this case, when the function "bar" is executed, it needs access to the variable "x", which
is in the parent function scope.  A fully dynamic version of this would be to create a code
object for "bar" that included a static scope with it.  The static scope would contain the 
variable "x".  When the function "bar" is executed outside the scope of "foo", it would
search through the static scope to find variables that are not defined in it.  So when we
return a function pointer

function a = foo(y)
  x = 3+y
  function b = bar(g)
     b = x+g
  end
  a = @bar
end

then "a" contains the code for "bar" and a workspace that defines "x".  So far, that's fine.
The question is what happens when we have to start chaining through scopes?  For example,

function a = foo(y)
  x = y + 2;
  function b = bar(g)
    k = x + g;
    function c = baz(p)
      c = p + k + x;
    end
    b = @baz
  end
  a = @b
end

So in this case, "baz" needs to access a variable "x" in the scope of "foo".  It seems that 
when we create the function pointer 

b = @baz

we need to create a workspace to store with it.  At that point, we walk through the function
scopes until we get to the parent scope and collect all variables that are defined.  So in this
case the function pointer b will have

b.code = <code>
b.workspace.x = <value for x>
b.workspace.k = <value for k>

When the code for "b" is executed, a "LOAD_DYN" reference for "x" will need to search the workspace
first.  

From a cache-implementation standpoint, the setup is a bit more complicated than earlier.  Ideally,
we want to mimic a normal implementation.  In a normal implementation, there is a global vector of
objects (memory).  Every object can then be uniquely defined by an address in global memory.  That
is fine without threads.  For threads, we want to have thread local and global memory.  Furthermore,
we don't want threads to stomp on each others memory addresses.  Thus, we need two different address
spaces.  Something like:

vector<Object> global_memory;
vector<Object> local_memory;

As I observe later, we also need a third address space for functions:

vector<Object> function_memory;

Where local_memory is specific to the given thread, and global_memory and function_memory is shared across all threads.
Each object can then be mapped to an address, which is simply the location of that object in memory.
A frame is then marked by simply taking a series of locations from local_memory.  Essentially, local_memory
is the stack for the VM, and global_memory is the (shared) global memory.  That works pretty well.
Persistent variables can be simply be allocated in global_memory, and given an address (depending on if they
are thread local or not).  

The use of addresses eliminates the need for string searches at runtime.  A frame will then consist of
the following operations:

frame::begin()
  local_memory.reserve(variables_used)
  registers.reserve(registers_used)
  name_cache.reserve(variables_used)
end

A LOAD opcode will then do the following.  If the name index referred to by the LOAD opcode has a memory
location, it will simply load the object from local_memory.  A LOAD opcode can also be mapped to global
memory.  Consider, for example, the implicit search for functions.

function b = foo(a)
   b = a + pi
end

Here, "pi" is a symbol defined in global memory (it is a function).  The OP_LOAD for "pi" will search
the symbol table for the frame.  As the symbol is not defined, it will search the global memory space for
the symbol.  If found, the value will be loaded and stored in local_memory in the space reserved for the
"pi" symbol.  This fetch operation is lazy, and triggered by a reference to a variable.  What happens when
we use "eval" to do the same thing?

function b = foo(a)
  eval('b = a + pi')
end

Essentially, the "eval" will be compiled into a series of opcodes that contain a reference to "pi".  That continues
the question to one of open frames.  For open frames, we do not want to reserve memory for the variables.  Those
variables are supposed to exist in the parent scope.  However, that is not guaranteed.  Consider for example

function b = foo(a)
  do_script_makes_x
  b = x + a
end

In this case, the script "do_script_makes_x" creates the variable "x", which is not present in the scope of function
"foo".  So this variable needs to be added to the local_memory allocated in the parent frame, and assigned an
address.  As a result, the OP_LOAD looks something like this:

OP_LOAD:
  Does symbol have a mapping?
    Yes --> load value from designated local memory location
    No  --> Does symbol exist in current frame?
                --> Yes, save mapping and return value
                --> Does symbol exist in function_memory?
                         Yes --> Fetch value from function_memory, and store in local cache & save mapping
                         No  --> throw exception "variable not defined"

OP_SAVE:
  Does symbol have a mapping?
    Yes --> save value to designated location
    No  --> Create symbol in current frame
                --> save mapping
                --> save value to designated location
              

So declared variables (globals, returns, etc.) will always have defined mappings.  Dynamic variables will just be added
to the current symbol table.  

If we don't use the processor stack for the frame.  We have something like

std::vector<Object> stack;

frame::begin(std::vector<Object> &stack)
{
  int sp = stack.size();
  stack.resize(stack.size() + num_registers + num_vars);
  Object *reg = &stack[sp-1];
  Object *var = &stack[sp+num_registers-1];
}

frame::end(std::vector<Object> &stack)
{
  stack.resize(sp);
}

In some cases, a frame will contain variables for which it has no references.  Consider

function foo
   script_that_defines_x
   script_that_uses_x

In this case, no reference to symbol "x" will exist in foo's frame.  Nor will the code segment
contain references to a variable x.  In fact, only the two names of the symbols will be defined
in foo's name list.  This means a frame must have a dynamic map of strings to indexes.  

frame {
  Object *registers;
  Object *variables;
  std::vector<Object> *stack;
  std::map<FMString,int> symbols;
}

Because the symbols map will require heap manipulation, it's not entirely clear what the 
advantage of avoiding it for registers and variables is.  It's certainly simpler to do

frame {
  std::vector<Object> registers;
  std::vector<Object> variables;
  std::map<FMString,int> symbols;
}


The OP_SAVE opcode can then do something like:

OP_SAVE reg,ndx
  - if (address[ndx])
      _closed_frame->variables[address[ndx]


Actually, that's not strictly true.  We can avoid the dynamic allocation of the symbol map
by doing the following.  

frame {
  Object *registers;
  Object *variables;
  std::vector<Object> *stack;
  std::map<FMString,int> dyn_symbols;
}

We can leave dyn_symbols unused unless a script inserts a new symbol into the frame.  The
search and resolve procedure for an OP_SAVE can then add the symbol to the frame.  Something
like:

OP_SAVE reg, ndx
  - if (address[ndx])
      _closed_frame->variables[address[ndx]]
    else
    {
      // Check to see if frame already has a symbol with this name
      if (f->has_symbol_named(names[ndx]))
        address[ndx] = f->get_symbol_address(names[ndx])
      else
      {
        f->add_dynamic_symbol(names[ndx])
        address[ndx] = f->get_symbol_address(names[ndx])
      } 
      f->variables[address[ndx]] = reg
    }


Can the Type class itself be an Object?  Perhaps, but I think it's too
difficult to do now.  

The next problem is to address function calls.  A function call should
be a pointer to a function with the following type signature.

Object func(ThreadContext *ctxt, const Object & argList, int nargout)

A function object can then have the following signature.

Need to build a function pool.  A function pool is a dictionary of
objects (assuming that we have built-in functions as objects as well -
I see no reason not to).

Need classes

Need closures

Need multi-function calls
 -- Change opcode so that passes the function argument count as an
 argument
 --- Something like:  OP_CALL <ret> <func> <arg> <retcount>
 --  Doesn't work, but we can put the number of returns into the
     return register, and then overwrite it.  Although it seems
     cleaner to put it into the argument list.

Need sparse matrices

http://www.ee.columbia.edu/~marios/matlab/Simplify%20your%20code%20with%20comma-separated%20lists.pdf

Interesting.  Here are some relevant snippets.


Comma-separated lists of variables, such as, x,y,z, appear frequently
in MATLAB code; they are most commonly found inside of {}, () and []
. In most cases, specifying the list of variables explicitly is
sufficient, but sometimes you need a more flexible technique. You can
store variable values in a cell array or structure array, and then
expand your data into a comma-separated list via c{:}, if c is a cell,
or via s.field, if s is a structure array. This simplifies certain
problems involving indexing and cell or structure array manipulation
and often allows you to write shorter, more efficient code. The
comma-separated list economizes the syntax for extracting multiple
values from cell and structure arrays. For example, c{:} is equivalent
to c{1},c{2},c{3},...c{end}, a list of values separated by
commas. Similarly for a structure array, s.field is equivalent to
s(1).field,s(2).field,...s(end). field. The four uses of
comma-separated lists are: 2003 Issues May 2003 2002 Issues October
2002 February 2002 Cleve's Corners 1994-2002 Past Issues Spring 2001
Winter 2001 Winter 2000 Summer 1999 Winter 1999 Subscribe Now ￼￼Within
[] to perform horizontal matrix concatenation. For example, if c is a
cell array containing scalars, where c{i} = i, you can create a matrix
consisting of the individual elements of c using [c{:}]. This usage
allows you to convert cell or structure arrays to numeric arrays in an
efficient and convenient manner.  As input or output parameters to
function calls. Functions that take a variable number of input
arguments or return a variable number of outputs can use
comma-separated lists. Use this technique when you need to build
argument lists to functions while your program is executing or when
you need to store the return values from functions in a single
variable, i.e., a cell or structure, for later processing. This usage
is common with functions that use varargin and varargout.  Within ()
to create an indexed expression. This usage is effective when dealing
with n- dimensional arrays (see Pattern 1, below).  Within {} to
create cell arrays. For example, b = {c{:}, magic(3)} creates a cell
array whose elements consists of the elements of cell c and a 3 -by-3
magic square.  Writing code with cell or structure arrays allows you
to take advantage of comma-separated list coding techniques, which are
the foundation for some of the programming patterns in MATLAB.
Pattern 1: Comma-separated lists and indexing Using comma-separated
lists in indexing operations can simplify and speed up your code. For
example, let’s look at the fftshift function.
￼￼￼￼http://www.mathworks.com/company/newsletter/spring01/patterns.shtml
6/8/2003 ￼MATLAB Programming Patterns Page 2 of 4 function y =
fftshift(x) numDims = ndims(x); idx = for k cell(1, numDims); =
1:numDims m = size(x, k); p = ceil(m/2); idx{k} = [p+1:m 1:p]; end y =
x(idx{:}); Given an N-dimensional matrix, fftshift swaps "half-spaces"
along each dimension. This is fundamentally an indexing operation:
given, for example, the vector a = [5 6 7 8 9 0], we can swap the left
and right halves of this vector with the command b = a([4:6 1:3]);
note that since a is one-dimensional, swapping requires only one index
vector. fftshift performs this kind of index-based swapping in N
dimensions and thus must construct N index vectors. The swapping
operation is simply y = x(index1,index2,..., indexN).  if ndims(x) ==
1 y = x(index1); else if ndims(x) == 2 y = x(index1, index2); end If
you are using explicit indexing, you’ll need to write one if statement
for each dimension you want your function to handle. A comma-separated
list makes it very easy to generalize this swapping operation to an
arbitrary number of dimensions.  fftshift stores the index vectors in
a cell array. Building this cell array is relatively simple. For each
of the N dimensions, determine the size of that dimension and find the
integer index nearest the midpoint. Then, construct a vector that
swaps the two halves of that dimension. Once all the vectors have been
collected into this cell array, a single MATLAB command performs the
swap: y = x(idx{:}); This technique produces an algorithm that is
dimension independent and compact.  Pattern 2: Manipulating data in
structure arrays You will often find that using comma-separated lists
to manipulate structure arrays makes it easier to write efficient
code. For example, if you want to search for and replace a certain
value in your structure array, you can easily create a function to do
this.  function index = findinstruct(a, value) % findinstruct takes a
% structure with the field value as its first % argument and a double
search value as its % second argument. This function assumes that the
% structure does not contain NaNs or empties.% Generate the indices of
the desired value index = find([a.value] == value); First, use
findinstruct to get the indices that match the value being
replaced. Note that
http://www.mathworks.com/company/newsletter/spring01/patterns.shtml
6/8/2003 MATLAB Programming Patterns Page 3 of 4 findinstruct converts
its input structure array to a numeric array using [] and a structure
field comma-separated list. Next, replace the existing value with the
new value by issuing this command: [a(index).value] = deal(newval);
You must use the function deal here, rather than a simple assignment
statement, because only functions can assign to multiple left-hand
side values; in this case, deal copies its input into each element of
the output. As a general rule, whenever you need to assign to or from
a comma-separated list, use deal in conjunction with the []
concatenation operator.  Comma-separated lists and objects MATLAB
classes can change the behavior of the cell and structure indexing
operators ({} and .) by overloading the subsref and subsasgn
functions. MATLAB calls subsref when an indexing operation appears on
the right hand side of an assignment statement, and subsasgn when the
indexing appears on the left hand side. For example: subsref: a =
obj{m:n}; subsasgn: obj.distance = value; If obj is an array of
objects, MATLAB applies the same rules it uses for cell and structure
arrays; thus the {} and . operators produce comma-separated
lists. When a comma- separated list appears on either side of an
assignment statement, MATLAB checks that the number of variables on
the left side of the assignment matches the number of values on the
right, and requires that you use deal to perform the assignment (see
Pattern 2). MATLAB performs this test before executing the overloaded
subsref and subsasgn functions by calling the numel function to count
the number of elements in obj{m:n} and obj.distance. The built-in
version of numel returns n—m+1 for the {m:n} case and prod(size(obj))
in the obj.distance case. If there is a mismatch between the number of
values on either side of the assignment as a result of calling numel,
an error occurs and the overloaded subsref and subsasgn functions are
not executed.  Therefore, if you want to modify the behavior of the
comma- separated list operators with respect to object arrays (for
example, your class may use {} to perform string indexing), you need
to indicate to MATLAB that these operators return 1, for the number of
elements. To do this you need to overload the numel function and have
it return 1 for both {} and . cases. With this overloaded numel in
place, the above example assignments do not require the explicit use
of deal, and MATLAB executes the overloaded subsref
andsubsasgnfunctions.  Summary See the help for numel for details on
how to use it.  Using comma-separated lists helps you write compact,
efficient, and extensible code. Because most cell and structure array
operations are built-in functions, the convenience and flexibility
does not come at the cost of performance. When working with
comma-separated lists, you need to remember to use deal
appropriately. And if you’re writing a MATLAB class, you should
consider whether or not to overload numel for that class. With these
points in mind, you will find comma-separated lists a powerful and
effective technique, and a very useful tool to add to your programming
toolkit.


This is also supposed to work...

C = cell(4, 6);
for k = 1:24,   C{k} = k * 2;   end

[c1 c2 c3 c4 c5 c6] = C{1,1:6};

Ultimately, it seems as though I need the concept of a variable
reference - i.e., something that acts as a pointer to an object.  This
allows for two improvements.  One is that the list

[a,b,c,d,e] = foo

can be handled (I think!) by creating a list of LHS references, and
then handling the assignments.  The other advantage is that variables
that are passed by reference work cleaner.  

But it's difficult to get right.  How does it work at the VM level?
Something like:

OP_LOAD_REF:
  // Get address
  REG1 = _ctxt->_objref->makeScalar(address);

// When we do an assignment what happens?  We have somthing like this:

a = 3;
b = &a; // b is now a pointer to a
b = 5;

Then OP_SAVE needs to bo changed so that if varfile[addr] is an
objref, that an additional level of indirection is used in the
assignment.  So that

OP_SAVE:
  if (varfile[addr].isReference())
    // decode address, and write it...

This works for the above example.  But not in the more general case.
How do you use it to pass arguments to functions?  Can't.  Because you
don't know a priori that an argument is passed by reference.  Also,
addresses are local to each frame.  Which means you cannot pass an
address from one frame to another.  

Simpler would be to have

Need slicing to work.

How do we translate A.foo{1:3} into 

A.foo{1},A.foo{2},A.foo{3}

1.  Take the tree of the form:

multi
   []
      variable
         (ident)A
         {}
            :
               (real)1
               (real)3

2.  We then want to select one of the various expressions (we know how
many subexpressions there are from the NUMEL or LENGTH operation
already complete.  How does the selector work?  

If we call A{1:3,2} = b, then setBraces is passed an argument that is a
_list_ of indices

-- so setBraces should be

CellType::setBraces(a, args, b)
{
	if (args is all scalars || b is scalar)
}


a = fixa
a(3,3,3) = 9 --> doesn't work!


(:,:,0) = 
   1.0000   2.0000   3.0000   4.0000
   5.0000   6.0000   7.0000   8.0000
        0        0        0        0

(:,:,1) = 
        0        0        0        0
        0        0        0        0
        0        0        0        0

(:,:,2) = 
        0        0        0        0
        0        0        0        0
        0        0        0   9.0000


(:,:,0) = 
   1.0000   2.0000   1.0000   2.0000   3.0000
   5.0000   6.0000   5.0000   6.0000   7.0000
        0        0        0        0        0

(:,:,1) = 
   4.0000        0        0        0        0
   8.0000        0        0        0        0
        0        0        0        0        0

(:,:,2) = 
        0        0        0        0        0
        0        0        0        0        0
        0        0        0   9.0000   9.0000

a = fixa
a(3,4,3) = 9
a(3,5,2) = 9


********************************************************************************

Structure indexing

Next major hurdle is structure indexing.  Need to spend some time on
this.

Removal of Null objects
